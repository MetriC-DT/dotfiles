# math snippets
global !p
def math():
	return vim.eval('Syntax_in_mathzone()') == '1'
endglobal

# fancy fractions
context "math()"
snippet // "Fraction" iA
\\frac{$1}{$2}$0
endsnippet

context "math()"
snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)\/' "Fraction" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

context "math()"
snippet '^.*\)/' "() Fraction" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
	if stripped[i] == ')': depth += 1
	if stripped[i] == '(': depth -= 1
	if depth == 0: break;
	i -= 1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet

# subscripts and superscripts
context "math()"
snippet '([^\s])pw' "power" irA
`!p snip.rv = match.group(1)`^{$1}$0
endsnippet

context "math()"
snippet '([^\s])sr' "squared" wrA
`!p snip.rv = match.group(1)`^2
endsnippet

context "math()"
snippet '([^\s])cb' "cubed" wrA
`!p snip.rv = match.group(1)`^3
endsnippet

context "math()"
snippet '([A-Za-df-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

context "math()"
snippet '([A-Za-z0-9])inv' "inverse" wrA
`!p snip.rv = match.group(1)`^{-1}
endsnippet

context "math()"
snippet '([A-Za-z0-9])tp' "transpose" wrA
`!p snip.rv = match.group(1)`^{\\top}
endsnippet

context "math()"
snippet '([0-9])exp' "exponent" wrA
`!p snip.rv = match.group(1)` \\times 10^{$1}
endsnippet

# symbols
context "math()"
snippet ooo "infinity" wA
\\infty
endsnippet

context "math()"
snippet >> ">>" iA
\gg
endsnippet

context "math()"
snippet << "<<" iA
\ll
endsnippet

context "math()"
snippet => "implies" iA
\\implies $0
endsnippet

context "math()"
snippet -> "to" iA
\\to $0
endsnippet

context "math()"
snippet !> "mapsto" iA
\\mapsto $0
endsnippet

context "math()"
snippet != "not equals" iA
\\neq $0
endsnippet

context "math()"
snippet rea "real" wA
\\mathbb{R} $0
endsnippet

# Other math snippets
context "math()"
snippet Vin "voltage in" wA
V_{in}
endsnippet

context "math()"
snippet Vout "voltage out" wA
V_{out}
endsnippet

context "math()"
snippet VDD "vdd" wA
V_{DD}
endsnippet

context "math()"
snippet hli "hline" wA
\\hline
$0
endsnippet

context "math()"
snippet sqr "square root" wA
\\sqrt{$1}
endsnippet

context "math()"
snippet abs "absolute value" wA
\left|$1\right|
endsnippet

context "math()"
snippet bb "mathbb" wA
\\mathbb{$1}
endsnippet

context "math()"
snippet == "and equals" wA
&=`!p
if t[2] and t[2][0] not in [' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

context "math()"
snippet apr "approximately equal" wA
\\approx $0
endsnippet

context "math()"
snippet eqv "equivalent" wA
\\equiv $0
endsnippet

context "math()"
snippet int "integral" w
\\int_{$1}^{$2} {$3} \\: d{$4}
endsnippet

context "math()"
snippet dif "differentiate" w
\\frac{d$1}{d${2:t}}
endsnippet

context "math()"
snippet pdif "partial differentiate" w
\\frac{\\partial $1}{\\partial ${2:t}}
endsnippet

context "math()"
snippet cdif "partial differentiate, with constant" w
\\left(\\frac{\\partial ${1:s}}{\\partial ${2:p}}\\right)_${3:T} $0
endsnippet

context "math()"
snippet br "bracket" wA
\\left[$1\\right]
endsnippet

context "math()"
snippet pa "parentheses" wA
\\left($1\\right)
endsnippet

context "math()"
snippet bc "braces" wA
\\left\\{$1\\right\\}
endsnippet

context "math()"
snippet wt "wide tilde" iA
\\widetilde{$1}
endsnippet

context "math()"
snippet vec "vector" iA
\\vec{$1}
endsnippet

context "math()"
snippet bar "bar" iA
\\overline{$1}
endsnippet

context "math()"
snippet dot "dot" wA
\\dot{$1}
endsnippet

context "math()"
snippet hat "hat" iA
\\hat{$1}
endsnippet

context "math()"
snippet sympy "sympy block " wA
sympy $1 sympy$0
endsnippet

context "math()"
snippet box "boxed environment" w
\\boxed{$1}
endsnippet


priority 10000
context "math()"
snippet '([^\s].+)box' "boxed environment aftermatch" wrA
\\boxed{`!p snip.rv=match.group(1)`}
endsnippet

context "math()"
snippet '([+-]?)(\d*\.\d+|\d+)si' "SI unit aftermatch" irA
\\SI{`!p snip.rv=match.group(1)+match.group(2)`}{$1}
endsnippet

context "math()"
snippet '=([^=]+)bex' "boxed environment equals aftermatch" wrA
= \\boxed{`!p snip.rv=match.group(1).strip()`}
endsnippet

context "math()"
snippet '([A-Za-z])wt' "wide tilde 2" riA
\\widetilde{`!p snip.rv=match.group(1)`}
endsnippet

context "math()"
snippet '([A-Za-z])vec' "vector" riA
\\vec{`!p snip.rv = match.group(1)`}$0
endsnippet

context "math()"
snippet '([A-Za-z])bar' "bar2" riA
\\overline{`!p snip.rv=match.group(1)`}
endsnippet

context "math()"
snippet '([A-Zabd-z])dot' "dot2" wrA
\\dot{`!p snip.rv=match.group(1)`}
endsnippet

context "math()"
snippet '([A-Za-z])hat' "hat2" riA
\\hat{`!p snip.rv=match.group(1)`}
endsnippet

context "math()"
snippet 'sympy(.*)sympy' "evaluate sympy" wrA
`!p
from sympy import *
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)
init_printing()
snip.rv = eval('latex(' + match.group(1) \
	.replace('\\', '') \
    .replace('^', '**') \
    .replace('{', '(') \
    .replace('}', ')') + ')')
`
endsnippet

